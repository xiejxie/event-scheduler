# PLANNABLE

## Iteration 2

 * Start date: October 20th, 2017
 * End date: November 17th, 2017

## Process

#### Roles & responsibilities

BackEnd Lead: Alisia
(This individual is in charge of keeping track of the tasks that need to be completed in the backend. This individual compiles a list of tasks they think should be completed in this iteration and assigns each tasks to their assigned coders. As conflicts arise, this person speaks with the whole group and facilitates a solution to the conflict that can be implemented).

BackEnd Coders: Alisia, Julian, Wes, Charles
(These individuals are assigned tasks by their respective lead. These individuals are responsible for coding the task and testing their code to ensure that it is functional. They are also responsible for reviewing the work of their peers and making adjustments that they feel would be beneficial. They must also communicate their changes to the rest of the group to ensure that everyone is on the same page). 

FrontEnd Lead: Jing Yi
(This individual has the same role as the BackEnd Lead but instead deals with the development of the frontend).

FrontEnd Coders: Jing Yi, Alison, Egan
(These individuals have the same role as the BackEnd coders but they develop the frontend).

Merging: Jing Yi, Alison
(These individuals review, request changes and merge pull requests made by team members: Jing Yi for frontend, Alison for backend.)

Designer: Egan
(This individual is in charge of creating mockups to indicate what we would like the UI of the application to look like. We had initially created some designs in iteration 1, but since then our plans have changed. This individual creates designs as specified by our group discussions. He then shares his designs with the FrontEnd coders who work together to implement the design in code).

Video Editor: Wes
(This individual is responsible for shooting and editing the video. This individual will create the video using the agreed upon script. They will then edit the video to ensure it is of proper length and that the different sections of the video flow well into each other).

Script Writers: Everyone
(All group members will be working together to come up with a script to be read out during the video. We will all be contributing towards a script that we feel meets the expectations of this deliverable).

#### Events

 Our planned meeting times have not changed since our last iteration, however the focus of each meeting will shift. We will still meet in person twice a week. We will have our first meeting during the tutorial on Tuesday. Since this is only an hour tutorial, we will reserve it for key conflicts that we would like to get resolved quickly. This could include asking another team member for clarification about the code they committed or asking another team member if they are ok with performing some functionality in a different way. 
 
 Our second meeting each week will be on Friday's for two hours in-person. This meeting will start off with the leads addressing any issues they have seen over the last week (product or process). As a team, we will discuss a solution and implement it the following week. We will also have both frontEnd and backEnd members quickly provide a synopsis of what new functionality has been implemented over the past week. As a group, we will discuss what needs to be done next and the team leads will assign tasks to each respective coder to be completed. We will finish off the meeting with everyone having a chance to voice any issues/concerns they might have.
 
 Lastly, we will be having constant conversations over Slack among the entire group. We will use Slack for conflict resolution and providing updates to the entire group. When someone has completed their task, they will post to Slack a very short summary of what has been completed to inform the entire group of the newest functionality available. As well, when someone is having any issues with their code, they can post to Slack and thus start a discussion amongst the group.

#### Artifacts

 We have two main process artifacts for this iteration, meeting minutes and a GitHub project task board. For each of our Friday meetings, we will assign one person who is in charge of creating the meeting minutes. This will include a brief summary of what was discussed and a section on upcoming tasks. By the end of the meeting, we will have a clear picture of what has already been completed and will spend the last half hour deciding what needs to be done next. As a group, we will agree upon a list of tasks that we feel can and should be completed by the next meeting. Once we have our general list of tasks, we will need to prioritize them to ensure that we are able to move the project along. Our main process for prioritization is deciding which tasks have the highest number of tasks dependent on it. We will go through each task one by one and figure out how many other tasks are dependent upon this one. Tasks with the highest number of dependencies will have the highest priority. Once we have sorted the tasks according to priority, we will assign each group member a task based on whether they are working frontEnd or backEnd. Each group member will be assigned at least one high priority task to ensure these tasks are completed as quickly as possible. Tasks will be assigned to group members based on whether they are working in frontEnd or backEnd, whether they have experience with the technical details of this task and whether they would like to work on this task. All of these details will be recorded in our meeting minutes' artifact.
 
 Once all of this information has been gathered in our meeting minutes, we will update the GitHub Project Task Board. The Task Board has columns for Backlog, BACKEND: Current sprint, FRONTEND: Current sprint, Completed and Video. At the end of each week, tasks from the Current sprint and Video columns will be moved to the Completed section (if not complete, will stay in these sections but will have the highest priority). We will then take the tasks discussed in the meeting minutes and add them to the respective current sprint and video columns. Each task will be given its own separate block which will include a description of the task and who is working on it. Tasks in the columns will be ordered by priority with highest priority at the top. Any tasks which are of lower priority will be added to the Backlog. Individuals who have extra time can move these tasks to the bottom of the current sprint columns and work on them if they can. As users complete tasks, they will move them to the completed column. 

#### Git / GitHub workflow

 We will be using a GitHub workflow very similar to that of the assignments. We have one master repository which has been created for us, project-team-15. Each group member will create their own fork of this repository. They will then clone this fork to their local machine and work on development locally. To avoid as many conflicts as possible, each group member is encouraged to sync their local fork with the master repository before they start working. This is to ensure that everyone is building off the code that has already been submitted. When someone has finished their task locally, they will push their changed files to their fork. They will then file a pull request from their fork to the master repository. The next individual who starts working on the project will first check the master repository for any open pull requests. They will go over the changes and if they agree with them, they will merge. If they do not agree with their approach or a conflict arises, this person will have a discussion with the person who filed the pull request about the best way to proceed. If they cannot come to a consensus, the rest of the group will be involved in this discussion.
 
 We mainly chose this workflow due to a lack of overhead and because of its simplicity. This workflow is very similar to that of the assignments and so we all have had a chance to work with this process before. Thus, going into this project, we knew that everyone was already familiar with this process. We knew that we would not have to waste time learning about new workflows or fine tuning the bugs that occur when working with a new workflow. As well, we chose this process because it is very streamlined. Although branches can be useful in some instances, we felt that it would overcomplicate our process instead. Since this is a very young application, there are several different directions our development could take. By having a branch for each one, we felt that we would end up becoming very confused about what was the correct direction we wanted to pursue. Having several branches would not help us to make our plans concrete enough to go forward because we may not be sure which direction we are going with. Thus, we wanted to go with the simplest approach of everyone having one fork. Lastly, we decided that the next person to work on the code should be the one to merge the previous pull request. This is to ensure that everyone gets a chance to try out this aspect of the workflow (which we will all have to know how to do once we start working full time). As well, this ensures that every team member is informed about all aspects of the development.

## Product

#### Goals and tasks

Goals
 * Ensure that everyone has the same and functioning development studio setup 
 * Have a concrete idea of how the application is going to flow during execution
 * Have a visual calendar printed out for the user by the application
 * Enable the user to interact with the calendar 
 * Ensure that user interactions are appropriately being recorded
 * Create a video to summarize our accomplishment over this iteration
 
Tasks (in order of importance)
1) Finish building image prototypes of UI
2) Decide on what input will be asked from user
BackEnd
3) Decide on a set of classes that we need to form the basis of the calendar (including abstract classes and where to use inheritance)
  * Need a separate class acting as the entire calendar
  * Need classes for each type of task (sleep, commute, class)
4) Implement these classes according to agreed upon specifications
5) Create main as entrance point into program where input will be asked and initialization will take place
FrontEnd
6) Create the calendar image that will be shown to the user
7) Create a new page for each new input that the user has to enter
8) Connect frontEnd with backEnd
9) Write script for video
10) Film video and record narration
11) Edit video
12) If time, think of an algorithm to prioritize the tasks users enter and how to implement it in code

#### Artifacts
   
   One of our main artifacts for this deliverable is CRC cards. Since this is our first iteration where we actually code, we are still trying to figure out exactly how we want to implement our application. CRC cards will be an extremely efficient way of communicating the general application process to all team members. Everyone will then be aware of what each class is supposed to do and where new functionality should be placed. This will help ensure that everyone is on the same page and prompt team members to ask questions if they have any. 
   
   Another artifact is images of the output of our code over the course of this iteration. Visually, this will help us to identify the progress that has been made in our code over the weeks. This will also act as a visual representation of how our project ideas have evolved over the past few weeks and how our code has had to change in order to reflect these shifts in ideas. We can also use these images to go back if we find that a new output format is actually worse than what we had before. 
   
   Our last artifact for this iteration will be our final video. This is an important artifact since it summarizes the general purpose of our application and what we have completed in this iteration. Thus, this helps us look forward to the next iteration and decide what we need to implement next. We can compare what we have already implemented with what we strive to implement in order to arrive at what is left to do.
